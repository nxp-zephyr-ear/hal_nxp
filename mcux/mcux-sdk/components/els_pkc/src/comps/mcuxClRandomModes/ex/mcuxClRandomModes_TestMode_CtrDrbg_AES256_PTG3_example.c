/*--------------------------------------------------------------------------*/
/* Copyright 2023 NXP                                                       */
/*                                                                          */
/* NXP Confidential. This software is owned or controlled by NXP and may    */
/* only be used strictly in accordance with the applicable license terms.   */
/* By expressly accepting such terms or by downloading, installing,         */
/* activating and/or otherwise using the software, you are agreeing that    */
/* you have read, and that you agree to comply with and are bound by, such  */
/* license terms. If you do not agree to be bound by the applicable license */
/* terms, then you may not retain, install, activate or otherwise use the   */
/* software.                                                                */
/*--------------------------------------------------------------------------*/

/**
 * @file  mcuxClRandomModes_TestMode_CtrDrbg_AES256_PTG3_example.c
 * @brief Example for the mcuxClRandomModes component
 *
 * @example mcuxClRandomModes_TestMode_CtrDrbg_AES256_PTG3_example.c
 * @brief   Example for the mcuxClRandomModes component
 */

#include <mcuxClRandom.h>
#include <mcuxClRandomModes.h>
#include <mcuxClSession.h>
#include <mcuxCsslFlowProtection.h>
#include <mcuxClCore_FunctionIdentifiers.h> // Code flow protection
#include <mcuxClExample_Session_Helper.h>
#include <mcuxClCore_Examples.h>
#include <mcuxClEls.h> // Interface to the entire mcuxClEls component
#include <mcuxClExample_ELS_Helper.h>

#define OUT_BUFFER_SIZE (MCUXCLRANDOMMODES_RESEED_INTERVAL_PTG3 * 2u)

static const uint32_t entropyInputInit[MCUXCLEXAMPLE_CEILING(MCUXCLRANDOMMODES_TESTMODE_CTR_DRBG_AES256_INIT_ENTROPY_SIZE, sizeof(uint32_t))] =
{
    /* Entropy for init (last byte is zero, because initSize is 71 bytes) */
    0x2848b943u, 0x9db0857au, 0x24947dbfu, 0xdf5d061bu,
    0x3810b90bu, 0xb0c41bdfu, 0xd1ec5f6au, 0x067b147au,
    0xcbc57229u, 0xf2862a00u, 0x781140fdu, 0xabfadd8du,
    0x42d44243u, 0xd09d2fb3u, 0x0cbaf6a9u, 0x4d318e71u,
    0xa5cd8cc0u, 0x00e52e1du
};

static const uint32_t entropyInputReseed[MCUXCLEXAMPLE_CEILING(MCUXCLRANDOMMODES_TESTMODE_CTR_DRBG_AES256_RESEED_ENTROPY_SIZE, sizeof(uint32_t))] =
{
    /* Entropy for reseed (last byte is zero, because initSize is 55 bytes) */
    0x8553d279u, 0x177481a3u, 0xfb7ca01du, 0x848b24fdu,
    0x4fc41239u, 0x5c28a84du, 0xe51096cau, 0xefdfd0e6u,
    0x5d06582eu, 0x7f11b69eu, 0x0cdd1c59u, 0xa27fe549u,
    0x3743696bu, 0x0031870au
};

static const uint32_t entropyInputGenerate[MCUXCLEXAMPLE_CEILING(MCUXCLRANDOMMODES_TESTMODE_CTR_DRBG_AES256_RESEED_ENTROPY_SIZE * 2u, sizeof(uint32_t))] =
{
    /* Entropy for first reseed at the beginning of the generate call (last byte is not used in first reseed, because reseedsize is 55) */
    0xbd98f427u, 0x22de991bu, 0xfb8d02abu, 0xde9141a9u,
    0x3b1e32e1u, 0x224c0a9eu, 0x8e41648du, 0x53384037u,
    0xd79dd5fau, 0x596b6c68u, 0x76661e1eu, 0x6a51e100u,
    0x10f264b1u, 0x1dfef494u,
/* Entropy for second reseed after 32 generated bytes (last byte from first reseed is used, two last bytes from this reseed are not used and set to zero, because reseedsize is 55) */
    0xb63075a8u, 0x6aea5058u, 0xd4003ac9u, 0x7576baa3u,
    0x801cc5c6u, 0xab22d6a4u, 0xd3dcd613u, 0x05be284du,
    0xf22f7fd6u, 0xcd00b43bu, 0xc5adfb33u, 0xf7c67ce0u,
    0xcf497dedu, 0x00007ed7u
};

/* Reference output is generated by running this example */
static const uint32_t refOutput[OUT_BUFFER_SIZE / sizeof(uint32_t)] =
{
    0xae9f48d6u, 0xe65ac43eu, 0x297df3eau, 0xfcfad27du,
    0x1903fe18u, 0xac2906a0u, 0xb8d6aadau, 0xd0d7a8a0u,
    0xd30a8957u, 0xcc7620a4u, 0xcc37d610u, 0x2aa97088u,
    0x193ac3f7u, 0xa7b78d8du, 0xe6278b5cu, 0xe1ba7253u
};

/** Performs an example usage of the mcuxClRandom and mcuxClRandomModes components with test mode.
 * @retval true  The example code completed successfully
 * @retval false The example code failed */
MCUXCLEXAMPLE_FUNCTION(mcuxClRandomModes_TestMode_CtrDrbg_AES256_PTG3_example)
{
    /**************************************************************************/
    /* Preparation                                                            */
    /**************************************************************************/

    /** Initialize ELS, Enable the ELS **/
    if(!mcuxClExample_Els_Init(MCUXCLELS_RESET_DO_NOT_CANCEL))
    {
        return MCUXCLEXAMPLE_STATUS_ERROR;
    }

    mcuxClSession_Descriptor_t sessionDesc;
    mcuxClSession_Handle_t session = &sessionDesc;
    MCUXCLEXAMPLE_ALLOCATE_AND_INITIALIZE_SESSION(session, MCUXCLRANDOMMODES_MAX_CPU_WA_BUFFER_SIZE, 0u);

    /* Allocate space for a test mode descriptor for an AES-256 CTR_DRBG PTG3. */
    uint32_t testModeDescBytes[(MCUXCLRANDOMMODES_TESTMODE_DESCRIPTOR_SIZE + sizeof(uint32_t) - 1U)/sizeof(uint32_t)];
    mcuxClRandom_ModeDescriptor_t *pTestModeDesc = (mcuxClRandom_ModeDescriptor_t *) testModeDescBytes;


    /**************************************************************************/
    /* Test mode creation and for an AES-256 CTR_DRBG PTG3 and preparation    */
    /* of known entropy input for later DRBG instantiation                    */
    /**************************************************************************/
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(cp_status, cp_token, mcuxClRandomModes_createTestFromNormalMode(
                                        pTestModeDesc,
                                        mcuxClRandomModes_Mode_CtrDrbg_AES256_PTG3,
                                        entropyInputInit
                                   ));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandomModes_createTestFromNormalMode) != cp_token) || (MCUXCLRANDOM_STATUS_OK != cp_status))
    {
        return MCUXCLEXAMPLE_STATUS_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();


    /**************************************************************************/
    /* Test mode initialization with known entropy input                      */
    /**************************************************************************/
    uint32_t context[MCUXCLRANDOMMODES_CTR_DRBG_AES256_CONTEXT_SIZE_IN_WORDS] = {0};

    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(ri_status, init_token, mcuxClRandom_init(
                                        session,
                                        (mcuxClRandom_Context_t)context,
                                        pTestModeDesc
                                   ));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_init) != init_token) || (MCUXCLRANDOM_STATUS_OK != ri_status))
    {
        return MCUXCLEXAMPLE_STATUS_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /**************************************************************************/
    /* Test mode reseeding with known entropy input                           */
    /**************************************************************************/

    /* Update entropy input to be taken for the upcoming reseed call */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(ue_status_1, ue_token_1, mcuxClRandomModes_updateEntropyInput(pTestModeDesc, entropyInputReseed));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandomModes_updateEntropyInput) != ue_token_1) || (MCUXCLRANDOM_STATUS_OK != ue_status_1))
    {
        return MCUXCLEXAMPLE_STATUS_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(rr_status, reseed_token, mcuxClRandom_reseed(session));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_reseed) != reseed_token) || (MCUXCLRANDOM_STATUS_OK != rr_status))
    {
        return MCUXCLEXAMPLE_STATUS_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();


    /**************************************************************************/
    /* Generate 64 random bytes. This will reseed the DRBG with known entropy */
    /* twice, once at the beginning of the generate call and once after 32    */
    /* generated bytes                                                        */
    /**************************************************************************/

    /* Update entropy input to be taken for the upcoming reseeding in generate */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(ue_status_2, ue_token_2, mcuxClRandomModes_updateEntropyInput(pTestModeDesc, entropyInputGenerate));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandomModes_updateEntropyInput) != ue_token_2) || (MCUXCLRANDOM_STATUS_OK != ue_status_2))
    {
        return MCUXCLEXAMPLE_STATUS_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /* Generate random bytes. */
    uint8_t outBuffer[OUT_BUFFER_SIZE] = {0u};
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(generate_status, generate_token, mcuxClRandom_generate(
                                        session,
                                        outBuffer,
                                        OUT_BUFFER_SIZE
                                   ));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_generate) != generate_token) || (MCUXCLRANDOM_STATUS_OK != generate_status))
    {
      return MCUXCLEXAMPLE_STATUS_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();


    /**************************************************************************/
    /* Compare the last generated random output to the expected output        */
    /**************************************************************************/

    bool outputIsExpected = mcuxClCore_assertEqual((const uint8_t *) outBuffer, (const uint8_t*) refOutput, OUT_BUFFER_SIZE);

    /* Return error if buffers are unequal */
    if(!outputIsExpected)
    {
      return MCUXCLEXAMPLE_STATUS_ERROR;
    }


    /**************************************************************************/
    /* Cleanup                                                                */
    /**************************************************************************/

    /* Random uninit. */
    MCUX_CSSL_FP_FUNCTION_CALL_BEGIN(ru_status, uninit_token, mcuxClRandom_uninit(session));

    if((MCUX_CSSL_FP_FUNCTION_CALLED(mcuxClRandom_uninit) != uninit_token) || (MCUXCLRANDOM_STATUS_OK != ru_status))
    {
      return MCUXCLEXAMPLE_STATUS_ERROR;
    }
    MCUX_CSSL_FP_FUNCTION_CALL_END();

    /** Destroy Session and cleanup Session **/
    if(!mcuxClExample_Session_Clean(session))
    {
        return MCUXCLEXAMPLE_STATUS_ERROR;
    }

    /** Disable the ELS **/
    if(!mcuxClExample_Els_Disable())
    {
        return MCUXCLEXAMPLE_STATUS_ERROR;
    }

    return MCUXCLEXAMPLE_STATUS_OK;
}
